uses write connection

function _write_controlpacket_CONNECT_verifyFieldPresent()
{
	local expectedFieldName="$1"
	local presentFieldName
	for presentFieldName in "${!write_controlpacket_CONNECT_arguments[@]}"
	do
		if [ "$presentFieldName" = "$expectedFieldName" ]; then
			return 0
		fi
	done
	return 1
}

function _write_controlpacket_PUBLISH_verifyFieldPresent()
{
	local expectedFieldName="$1"
	local presentFieldName
	for presentFieldName in "${!write_controlpacket_PUBLISH_arguments[@]}"
	do
		if [ "$presentFieldName" = "$expectedFieldName" ]; then
			return 0
		fi
	done
	return 1
}

function _write_controlpacket_SUBSCRIBE_verifyFieldPresent()
{
	local expectedFieldName="$1"
	local presentFieldName
	for presentFieldName in "${!write_controlpacket_SUBSCRIBE_arguments[@]}"
	do
		if [ "$presentFieldName" = "$expectedFieldName" ]; then
			return 0
		fi
	done
	return 1
}

function _write_controlpacket_guardUtf8StringOrBinaryFieldLength()
{
	if [ $3 -lt 0 ]; then
		connection_messageFAIL $1 "Field $2 must not be negative (ie not $3)"
	fi
	if [ $3 -gt 65535 ]; then
		connection_messageFAIL $2 "Field $2 must be less than 65,536 characters long, not $3"
	fi
}

function write_controlpacket_CONNECT()
{
	# 8 byte preamble and 2 byte keep-alive
	local -i remainingLength=10
	local -i connectFlags=0
	
	read_FIX 'password, will payload can contain embedded ASCII NULL!'
	
	if [ "${write_controlpacket_CONNECT_arguments_clean_session+unset}" = 'unset' ]; then
		local -ir clean_session=0
	else
		case "$write_controlpacket_CONNECT_arguments_clean_session" in
			
			yes|true|on|1)
				connectFlags=$(( connectFlags + 1 << 1 ))
				local -ir clean_session=1
			;;
			
			no|false|off|0)
				local -ir clean_session=0
			;;
			
			*)
				connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_clean_session must be 'yes', 'no' or unset, not '$write_controlpacket_CONNECT_arguments_clean_session'"
			;;
			
		esac
	fi

	if [ "${write_controlpacket_CONNECT_arguments_will_retain+unset}" = 'unset' ]; then
		local -r will_retain='no'
	else
		case "$write_controlpacket_CONNECT_arguments_will_retain" in
			
			yes|true|on|1)
				local -r will_retain='yes'
			;;
			
			no|false|off|0)
				local -r will_retain='no'
			;;
			
			*)
				connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_will_retain must be 'yes', 'no' or unset, not '$write_controlpacket_CONNECT_arguments_will_retain'"
			;;
			
		esac
	fi
	
	# If we have a will topic, then will retain, etc come into play
	if [ "${write_controlpacket_CONNECT_arguments_will_topic+unset}" = 'unset' ]; then
		local -i checksCount=0
		if [ "${write_controlpacket_CONNECT_arguments_will_message+unset}" = 'unset' ]; then
			checksCount=$((checksCount+1))
		fi
		if [ "${write_controlpacket_CONNECT_arguments_will_qos+unset}" = 'unset' ]; then
			checksCount=$((checksCount+1))
		fi
		if [ "${write_controlpacket_CONNECT_arguments_will_retain+unset}" = 'unset' ]; then
			checksCount=$((checksCount+1))
		fi
		if [ $checksCount -ne 3 ]; then
			connection_messageFAIL CONNECT "if write_controlpacket_CONNECT_arguments_will_topic is unset, then write_controlpacket_CONNECT_arguments_will_message ($write_controlpacket_CONNECT_arguments_will_message), write_controlpacket_CONNECT_arguments_will_retain ($write_controlpacket_CONNECT_arguments_will_retain) and write_controlpacket_CONNECT_arguments_will_qos ($write_controlpacket_CONNECT_arguments_will_qos) must be unset"
		fi
		local -ir will_topic_fieldLength=-1
		local -ir will_message_fieldLength=-1
	else
		local -r will_topic="$write_controlpacket_CONNECT_arguments_will_topic"
		local -ir will_topic_fieldLength=${#will_topic}
		if [ $will_topic_fieldLength -eq 0 ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_will_topic must be at least one character long, not '' (empty)"
		fi
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'write_controlpacket_CONNECT_arguments_will_topic' $will_topic_fieldLength
		remainingLength=$(( remainingLength + 2 + will_topic_fieldLength ))

		if [ "${write_controlpacket_CONNECT_arguments_will_message+unset}" = 'unset' ]; then
			connection_messageFAIL CONNECT "if write_controlpacket_CONNECT_arguments_will_topic is set ($write_controlpacket_CONNECT_arguments_will_topic) then write_controlpacket_CONNECT_arguments_will_message must be set"
		fi
		local -r will_message="$write_controlpacket_CONNECT_arguments_will_message"
		local -ir will_message_fieldLength=${#will_message}
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'write_controlpacket_CONNECT_arguments_will_message' $will_message_fieldLength
		remainingLength=$(( remainingLength + 2 + will_message_fieldLength ))
		
		# Will Flag
		connectFlags=$(( connectFlags + 1 << 2 ))
		
		# Will QoS
		if [ "${write_controlpacket_CONNECT_arguments_will_qos+unset}" = 'unset' ]; then
			local -ir will_qos=0
		else
			local -ir will_qos=${write_controlpacket_CONNECT_arguments_will_qos+unset}
			if [ $will_qos != "${write_controlpacket_CONNECT_arguments_will_qos+unset}" ]; then
				connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_will_qos must be 0, 1 or 2, not '$write_controlpacket_CONNECT_arguments_will_qos'"
			fi
			
			if [ $will_qos -lt 0 ]; then
				connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_will_qos must be 0, 1 or 2, not '$write_controlpacket_CONNECT_arguments_will_qos'"
			fi
			
			if [ $will_qos -gt 2 ]; then
				connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_will_qos must be 0, 1 or 2, not '$write_controlpacket_CONNECT_arguments_will_qos'"
			fi
		fi
		connectFlags=$(( connectFlags + will_qos << 3 ))
		
		# Will Retain
		if [ "${write_controlpacket_CONNECT_arguments_will_retain+unset}" = 'unset' ]; then
			:
		elif [ -n "$write_controlpacket_CONNECT_arguments_will_retain" ]; then
			case "$write_controlpacket_CONNECT_arguments_will_retain" in
			
				yes|true|on|1)
					connectFlags=$(( connectFlags + 1 << 5 ))
				;;
			
				no|false|off|0)
					:
				;;
			
				*)
					connection_messageFAIL CONNECT "will_retain must be 'yes', 'no' or unset, not '$write_controlpacket_CONNECT_arguments_will_retain'"
				;;
			
			esac
		else
			connection_messageFAIL CONNECT "will_retain must be 'yes', 'no' or unset, not '' (empty)"
		fi
	fi
	
	if [ "${write_controlpacket_CONNECT_arguments_keep_alive+unset}" = 'unset' ]; then
		local -ir keep_alive=0
	else
		local -ir keep_alive=$write_controlpacket_CONNECT_arguments_keep_alive
		if [ "$keep_alive" != "$write_controlpacket_CONNECT_arguments_keep_alive" ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_keep_alive must be a decimal integer number of seconds, not $write_controlpacket_CONNECT_arguments_keep_alive (Octal and Hexadecimal numbers are not supported)"
		fi
		if [ $keep_alive -lt 0 ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_keep_alive must not be negative, ie not '$write_controlpacket_CONNECT_arguments_keep_alive'"
		fi
		if [ $keep_alive -gt 65535 ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_keep_alive must be less than 65,536 seconds, ie not '$write_controlpacket_CONNECT_arguments_keep_alive'"
		fi
	fi
	
	read_FIX 'consider loading username, password, will details based on client-id...'
	read_FIX 'keep-alive is based on server connection details - it is a broker specific thing - goes with broker configurations'
	
	if [ "${write_controlpacket_CONNECT_arguments_client_id+unset}" = 'unset' ]; then
		# generate a random client-id
		if [ $clean_session -eq 0 ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_client_id can not be unset (random) if clean_session is 'no' (0)"
		fi
		local -r client_id="$((random_characterForEncodingLettersAndNumbers))"
		local -ir client_id_fieldLength=${#client_id}
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'write_controlpacket_CONNECT_arguments_client_id' $client_id_fieldLength
		remainingLength=$(( remainingLength + 2 + client_id_fieldLength ))
	elif [ -z "$write_controlpacket_CONNECT_arguments_client_id" ]; then
		if [ $clean_session -eq 0 ]; then
			connection_messageFAIL CONNECT "write_controlpacket_CONNECT_arguments_client_id can not be '' (empty) if clean_session is 'no' (0)"
		fi
		local -r client_id=''
		local -ir client_id_fieldLength=0
	else
		local -r client_id="$write_controlpacket_CONNECT_arguments_client_id"
		local -ir client_id_fieldLength=${#client_id}
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'write_controlpacket_CONNECT_arguments_client_id' $client_id_fieldLength
		remainingLength=$(( remainingLength + 2 + client_id_fieldLength ))
	fi

	# Note colon omitted for unset
	if [ "${write_controlpacket_CONNECT_arguments_username+unset}" = 'unset' ]; then
		local -ir username_fieldLength=-1
	else
		local -r username="$write_controlpacket_CONNECT_arguments_username"
		local -ir username_fieldLength=${#username}
		
		remainingLength=$(( remainingLength + 2 + username_fieldLength ))
		connectFlags=$(( connectFlags + 1 << 7 ))
		
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'username' $username_fieldLength
	fi
	
	read_FIX 'Support a binary password (embedded NULs)'
	read_FIX 'Use .netrc for password! (or a password file; required if we are going to use embedded NULs for SASL)'
	
	# Note colon omitted for unset
	if [ "${write_controlpacket_CONNECT_arguments_password+unset}" = 'unset' ]; then
		local -ir password_fieldLength=-1
	else
		local -r password="$write_controlpacket_CONNECT_arguments_password"
		local -ir password_fieldLength=${#password}
		
		remainingLength=$(( remainingLength + 2 + password_fieldLength ))
		connectFlags=$(( connectFlags + 1 << 6 ))
		
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength CONNECT 'password' $password_fieldLength
	fi
	
	connection_status=GOOD
	{
		# CONNECT 1 << 4 in Octal (1 byte)
		printf '\020'
	
		# Remaining Length (1 - 3 bytes; 4 bytes would never be required)
		write_remainingLength $remainingLength
	
		# protocol name (MSB, LSB, MQTT), protocol level (7 bytes)
		printf '\000\004MQTT\004'
	
		# connect flag (1 byte)
		write_byte $connectFlags
	
		# two-byte size of Keep Alive (2 bytes)
		write_twoByteLength $keep_alive
	
		# client id
		write_twoByteLength $client_id_fieldLength
		echo -nE "$client_id"
	
		# will topic & will message
		if [ $will_topic_fieldLength -ne -1 ]; then
			write_twoByteLength $will_topic_fieldLength
			echo -nE "$will_topic"
			write_twoByteLength $will_message_fieldLength
			echo -nE "$will_message"
		fi
	
		# username
		if [ $username_fieldLength -ne 1 ]; then
			write_twoByteLength $username_fieldLength
			echo -nE "$username"
		fi
	
		# password
		if [ $password_fieldLength -ne 1 ]; then
			write_twoByteLength $password_fieldLength
			echo -nE "$password"
		fi
	} >&10 2>&11 || connection_status=BAD
}

# more optimised versions of this function are possible, eg with pre-set flags, flags as ints, etc
function write_controlpacket_PUBLISH()
{
	local -i remainingLength=0
	
	# 3 << 4
	local -i controlPacketTypeAndFlags=48
	local -r dup=${write_controlpacket_PUBLISH_arguments['dup']}
	case "$dup" in
		
		yes)
			controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 << 3 ))
		;;
		
		no)
			:
		;;
		
		*)
			connection_messageFAIL PUBLISH "dup must be yes or no, not '$dup'"
		;;
		
	esac

	if ! _write_controlpacket_PUBLISH_verifyFieldPresent 'qos'; then
		local -ir packet_identifier=-1
	else
		case "$qos" in 
		
			0)
				local -ir packet_identifier=-1
			;;
		
			1|2)
				controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + qos << 2 ))
				if ! _write_controlpacket_PUBLISH_verifyFieldPresent 'packet_identifier'; then
					connection_messageFAIL PUBLISH "messages published at QoS 1 or 2 must have a packet_identifier"
				fi
				local -ir packet_identifier=${write_controlpacket_PUBLISH_arguments['packet_identifier']}
				remainingLength=$(( remainingLength + 2 ))
			;;
		
			3)
				connection_messageFAIL PUBLISH "qos 3 is reserved"
			;;
		
			*)
				connection_messageFAIL PUBLISH "qos must be 0-2, not '$qos'"
			;;
		esac
	fi
	
	local -r retain="${write_controlpacket_PUBLISH_arguments['retain']}"
	case "$retain" in
		
		yes)
			controlPacketTypeAndFlags=$(( controlPacketTypeAndFlags + 1 ))
		;;
		
		no)
			:
		;;
		
		*)
			connection_messageFAIL PUBLISH "retain must be yes or no, not '$retain'"
		;;
		
	esac
	
	# BUG: We don't check for wildcards, ASCII NULL, or empty topic names
	if ! _write_controlpacket_PUBLISH_verifyFieldPresent 'topic_name'; then
		connection_messageFAIL PUBLISH "topic_name is not present"
	fi
	local -r topic_name="${write_controlpacket_PUBLISH_arguments['topic_name']}"
	local -ir topic_name_fieldLength=${#topic_name}
	_write_controlpacket_guardUtf8StringOrBinaryFieldLength PUBLISH topic_name $topic_name_fieldLength
	
	remainingLength=$(( remainingLength + 2 + topic_name_fieldLength ))
	
	read_FIX "We don't handle binary payloads containing ASCII NULL, and we really ought to also allow the use of files (with offsets, sizes, too, for firmware transmissions) and base64 encoded data"
	
	if _write_controlpacket_PUBLISH_verifyFieldPresent 'payload'; then
		local -r payload="${write_controlpacket_PUBLISH_arguments['payload']}"
		remainingLength=$(( remainingLength + 2 + ${#payload} ))
	else
		local -r payload=""
	fi
	
	echo -ne "${write_byteCache[$controlPacketTypeAndFlags]}"
	write_remainingLength $remainingLength >&10 2>&11
	
	write_twoByteLength $topic_name_fieldLength >&10 2>&11
	echo -nE "$topic_name" >&10 2>&11
	
	if [ $packet_identifier -ne -1 ]; then
		write_twoByteLength $packet_identifier >&10 2>&11
	fi
	
	echo -nE "$payload" >&10 2>&11
}

function write_controlpacket_PUBACK()
{
	local -ir packetIdentifier=$1
	
	# 4 << 4 in octal, followed by 2 (remaining length)
	printf '\100\002' >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
}

function write_controlpacket_PUBREC()
{
	local -ir packetIdentifier=$1
	
	# 5 << 4 in octal, followed by 2 (remaining length)
	printf '\120\002' >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
}

function write_controlpacket_PUBREL()
{
	local -ir packetIdentifier=$1
	
	# 6 << 4 in octal + 1 << 1, followed by 2 (remaining length)
	printf '\142\002' >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
}

function write_controlpacket_PUBCOMP()
{
	local -ir packetIdentifier=$1
	
	# 7 << 4 in octal, followed by 2 (remaining length)
	printf '\160\002' >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
}

function write_controlpacket_SUBSCRIBE()
{
	local -ir packetIdentifier=$1
	shift 1

	local -i remainingLength=2
	
	if [ $# -lt 2 ]; then
		connection_messageFAIL SUBSCRIBE "control packets must have at least one topic filter - qos pair"
	fi

	declare -ai topic_filters_size=()
	declare -a topic_filters=()
	declare -ai topic_filters_qos=()
	
	local topic_filter
	local -i topic_filter_fieldLength
	local qos
	while $# -gt 0
	do
		if [ $# -lt 2 ]; then
			connection_messageFAIL SUBSCRIBE "control packets must have balanced topic_fiter - qos pairs"
		fi
		topic_filter="$1"
		if [ "${#topic_filter}" -eq 0 ]; then
			connection_messageFAIL SUBSCRIBE "topic_filter can not be empty"
		fi
		qos="$2"
		case $qos in
			0|1|2)
			
			;;
			
			3)
				connection_messageFAIL SUBSCRIBE "qos 3 is reserved"
			;;
			
			*)
				connection_messageFAIL SUBSCRIBE "qos must be 0-2, not '$qos'"
			;;
		esac
		
		# 3 is from 2 for length and 1 for QoS byte
		topic_filter_fieldLength=${#topic_filter}
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength SUBSCRIBE topic_filter $topic_filter_fieldLength
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength 
		remainingLength=$(( remainingLength + 3 + topic_filter_fieldLength ))
		topic_filters_size+=($topic_fiter_fieldLength)
		topic_filters+=(topic_filter)
		topic_filters_qos+=($qos)
		shift 2
	done
	
	# 8 << 4 + 1 << 1 in octal
	printf '\202' >&10 2>&11
	write_remainingLength $remainingLength >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
	
	local -i index
	for index in ${!topic_filters[@]}
	do
		write_twoByteLength ${topic_filters_size[$index]} >&10 2>&11
		echo -nE "${topic_filters[$index]}" >&10 2>&11
		write_byte "${topic_filters_qos[$index]}" >&10 2>&11
	done
}

function write_controlpacket_SUBACK()
{
	local -ir packetIdentifier=$1
	shift 1
	
	local -ir remainingLength=$(( 2 + ${#} ))
	
	# 9 << 4 in octal
	printf '\220' >&10 2>&11
	
	write_remainingLength $remainingLength >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
	local -i resultCode
	for resultCode in "$@"
	do
		case $resultCode in
			
			0|1|2|128)
				:
			;;
			
			*)
				connection_messageFAIL SUBACK "resultCodes must be 0, 1, 2 or 128, not '$resultCode'"
			;;
			
		esac
	done
}

function write_controlpacket_UNSUBSCRIBE()
{
	local -ir packetIdentifier=$1
	shift 1

	local -i remainingLength=2
	
	if [ $# -eq 0 ]; then
		connection_messageFAIL UNSUBSCRIBE "control packets must have at least one topic filter"
	fi

	declare -ai topic_filters_size=()
	declare -a topic_filters=()
	
	local topic_filter
	local -i topic_filter_fieldLength
	local qos
	while $# -gt 0
	do
		topic_filter="$1"
		if [ "${#topic_filter}" -eq 0 ]; then
			connection_messageFAIL UNSUBSCRIBE "topic_filter can not be empty"
		fi
		
		topic_filter_fieldLength=${#topic_filter}
		_write_controlpacket_guardUtf8StringOrBinaryFieldLength UNSUBSCRIBE topic_filter $topic_filter_fieldLength
		remainingLength=$(( remainingLength + 2 + topic_filter_fieldLength ))
		topic_filters_size+=($topic_fiter_fieldLength)
		topic_filters+=(topic_filter)
		shift 2
	done
	
	# 10 << 4 + 1 << 1 in octal
	printf '\242' >&10 2>&11
	write_remainingLength $remainingLength >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
	
	local -i index
	for index in ${!topic_filters[@]}
	do
		write_twoByteLength ${topic_filters_size[$index]} >&10 2>&11
		echo -nE "${topic_filters[$index]}" >&10 2>&11
	done
}

function write_controlpacket_UNSUBACK()
{
	local -ir packetIdentifier=$1
	
	# 11 << 4 in octal, followed by 2 (remaining length)
	printf '\260\002' >&10 2>&11
	
	write_twoByteLength $packetIdentifier >&10 2>&11
}

function write_controlpacket_PINGREQ()
{
	# 12 << 4 in octal, followed by 0 (remaining length)
	printf '\300\000' >&10 2>&11
}

function write_controlpacket_PINGRESP()
{
	# 13 << 4 in octal, followed by 0 (remaining length)
	printf '\320\000' >&10 2>&11
}

function write_controlpacket_DISCONNECT()
{
	# 14 << 4 in octal, followed by 0 (remaining length)
	printf '\340\000' >&10 2>&11
}
