function backend_client_defaultOptions()
{
	# Choices are auto (best fit), inet4, inet6, unix
	backend_client_options['inetFamily']=auto
	backend_client_options['localInterface']=''
	backend_client_options['localAddress']=''
	backend_client_options['localPort']=''
	
	backend_client_options['proxyKind']='none'
	backend_client_options['proxyAddress']=''
	backend_client_options['proxyPort']=''

	backend_client_options['timeout']=''
	
	backend_client_options['remoteAddress']='127.0.0.1'
	backend_client_options['remotePort']=''
}

backend_client_temporaryPath=""
function backend_client_createTemporaryPath()
{
	temporaryFiles_newFolderToRemoveOnExit
	backend_client_temporaryPath="$TMP_FOLDER"
}

backend_client_debugLogPath=""
function backend_client_createDebugLog()
{
	backend_client_debugLogPath="$backend_client_temporaryPath"/client.debug.log
	touch "$backend_client_debugLogPath"
}

backend_client_inboundPipe=''
backend_client_outboundPipe=''
function backend_client_createNamedPipes()
{
	backend_client_inboundPipe="$backend_client_temporaryPath"/client.inbound.pipe
	backend_client_outboundPipe="$backend_client_temporaryPath"/client.outbound.pipe
	mkfifo "$backend_client_inboundPipe" "$backend_client_outboundPipe"
}

function backend_client_normaliseOptions()
{
	if [ -z "${backend_client_options['proxyKind']}" ]; then
		backend_client_options['proxyKind']='none'
	else
		case "${backend_client_options['proxyKind']}" in
			
			none|socks4|socks5|https)
				:
			;;
			
			*)
				bishbosh_exitError "Backend client 'proxyKind' '${backend_client_options['proxyKind']}' is not known"
			;;
		esac
	fi

	if [ "${backend_client_options['proxyKind']}" = 'none' ]; then
		if [ -n "${backend_client_options[proxyAddress]}" ]; then
			bishbosh_exitError "Backend client 'proxyAddress' is set but proxyKind is missing or none"
		fi
		if [ -n "${backend_client_options[proxyPort]}" ]; then
			bishbosh_exitError "Backend client 'proxyPort' is set but proxyKind is missing or none"
		fi
	else
		if [ -z "${backend_client_options[proxyAddress]}" ]; then
			bishbosh_exitError "Backend client 'proxyAddress' is not set but proxyKind is ${backend_client_options['proxyKind']}"
		fi
		if [ -z "${backend_client_options[proxyPort]}" ]; then
			case "${backend_client_options['proxyKind']}" in
				
				socks4|socks5)
					backend_client_options['proxyPort']=1080
				;;
				
				https)
					backend_client_options['proxyPort']=3128
				;;
				
			esac
			
		fi
	fi
	
	# depends on security setting
	if [ -z "${backend_client_options[remotePort]]}" ]; then
		if [ "${backend_client_options['proxyKind']}" != 'unix' ]; then
			backend_client_options['remotePort']=1883
		fi
	fi
	
	if [ "${backend_client_options['proxyKind']}" = 'unix' ]; then
		if [ -n "${backend_client_options[remotePort]]}" ]; then
			bishbosh_exitError "Backend client 'inetFamily' is unix but a remotePort of '${backend_client_options[remotePort]]}' has been set"
		fi
	fi
	
	local -r remoteAddress="${backend_client_options['remoteAddress']}"
	if [ -z "$remoteAddress" ]; then
		bishbosh_exitError "Backend client 'remoteAddress' is not set"
	else
		if [ "$remoteAddress" = "${backend_client_options[proxyAddress]}" ]; then
			if [ "${backend_client_options[proxyPort]}" = "${backend_client_options[proxyPort]}" ]; then
				bishbosh_exitError "Backend client 'proxyAddress' and 'proxyPort' are the same as 'remoteAddress' and 'remotePort'"
			fi
		fi
	fi
}

backend_kind=""
backend_name=""
backend_client_prefix=""
backend_client_processIdsToKill=()
function backend_client_start()
{	
	backend_kind="$1"
	backend_name="$2"
	backend_client_processIdsToKill=()
	
	backend_client_normaliseOptions

	backend_client_createTemporaryPath
	
	backend_client_createDebugLog
	
	backend_client_createNamedPipes
	
	backend_client_prefix="backend_client_${backend_kind}_${backend_name}"
	uses backend.client.${backend_kind}.${backend_name}
	${backend_client_prefix}_start
}

function backend_client_loop()
{
	exec 10<"$backend_client_outboundPipe"
	
	write_controlpacket_CONNECT >&10
	
	while true
	do
		# We should have a connection object we update
		read_controlpacket_next
	
		write_controlpacket_PINGREQ >&10
	
		read_controlpacket_next
	
		write_controlpacket_DISCONNECT >&10
		
		done < <(${backend_client_prefix}_read)

	exec 10<&-
	
	return 0
	
	
	# we could publish messages that are 'dropped' into a folder. The folder name could be the topic, the QoS a folder prefix, leaving just a way to notify
	# could be a find with a sort, followed by a pause (for a read cycle). Or the read cycle could be size-based, eg after writing 4Kb or 1 second?
	
	# we call a callback (or callbacks) on message recipt. This can be either a built-in or a function or an external program. Slight problem in sending array variables to a program
	# consider not using arrays for write_controlpacket_*
	
	# message records call callbacks. These can be either built in functions or real programs; we pass a QoS, Topic and Path to content (or named pipe) (or an array of functions/programs)
	
	# check that the underlying process(es) have not died, otherwise we could block writing to the FIFO...
	# we should not write more than 4Kb to the FIFO...
	
}

function backend_client_stop()
{
	${backend_client_prefix}_stop
	
	backend_client_deleteNamedPipes
}

function backend_client_deleteNamedPipes()
{
	rm -rf "$backend_client_inboundPipe"
	rm -rf "$backend_client_outboundPipe"
}

function _backend_client_stop()
{
	local -i pid
	for pid in ${backend_client_processIdsToKill[@]}
	do
		kill -9 $pid 1>/dev/null 2>/dev/null || true
	done
	backend_client_processIdsToKill=()
}
