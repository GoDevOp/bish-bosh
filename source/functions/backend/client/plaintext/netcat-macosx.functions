features()
{
	unix=yes
	distributions=(MacOSX)
	proxySocks4=yes
	proxySocks4UserPassword=no
	proxySocks5=yes
	proxySocks5UserPassword=no
	proxyHttp=no
	proxyHttpUsername=yes
	proxyHttpPassword=no
	proxyHttps=yes
	proxyHttpsUsername=no
	proxyHttpsPassword=no
}

function backend_client_plaintext_netcat-macosx_start()
{
	options_prepare 'nc'
	
	backend_client_get_tunelling
	
	LOGIC HERE IS PROBABLY WRONG!
	should be:
	need to fix all other code
	
	if [ "${backend_client_options_localInterface+unset}" != 'unset' ]; then
		# backend_client_options_localInterface is unset
		options_add '-b' "$backend_client_options_localInterface"
	else
		if [ -z "$backend_client_options_localInterface" ]; then
			bishbosh_exitError 'backend_client_options_localInterface '$backend_client_options_localInterface' (empty) is invalid'
		fi
	fi
	
	
	if [ ${backend_client_options_localInterface+unset} != 'unset' ]; then
		if [ -z "$backend_client_options_localInterface" ]; then
			bishbosh_exitError 'backend_client_options_localInterface '$backend_client_options_localInterface' (empty) is invalid'
		fi
		options_add '-b' "$backend_client_options_localInterface"
	fi
	
	if [ ${backend_client_options_localAddress+unset} != 'unset' ]; then
		if [ -z "$backend_client_options_localAddress" ]; then
			bishbosh_exitError 'backend_client_options_localAddress '$backend_client_options_localAddress' (empty) is invalid'
		fi
		options_add '-s' "$backend_client_options_localAddress"
	fi
	
	if [ ${backend_client_options_localPort+unset} != 'unset' ]; then
		if [ -z "$backend_client_options_localPort" ]; then
			bishbosh_exitError 'backend_client_options_localPort '$backend_client_options_localPort' (empty) is invalid'
		fi
		options_add '-s' "$backend_client_options_localPort"
	fi
	
	local -i timeout
	backend_client_get_timeout
	if [ $timeout -gt 0 ]; then
		options_add '-w' $timeout
	fi
	
	local inetFamily
	backend_client_get_inetFamily
	
	local proxyKind
	backend_client_get_proxyKind
	
	if [ "$proxyKind" != 'none' ]; then
		
		local proxyAddress
		backend_client_get_proxyAddress
		
		local -i proxyPort
		backend_client_get_proxyPort
		
		local netcatProxyType
		case "$backend_client_get_proxyKind" in
		
			socks4)
				netcatProxyType='4'
			;;
		
			socks5)
				netcatProxyType='5'
			;;
		
			https)
				netcatProxyType='connect'
			;;
		
			*)
				bishbosh_exitError "proxyKind '$proxyKind' is not supported"
			;;
		
		esac

		options_add '-X' "$netcatProxyType"
		options_add '-x' "${proxyAddress}:${proxyPort}"
	fi
	
	local remoteAddress
	backend_client_get_remoteAddress
	options_add "$backend_client_options_remoteAddress"
	
	case "$inetFamily" in
		
		auto|inet4|inet6)
			local -i remotePort
			backend_client_get_remotePort
			options_add $remotePort
		;;
		
		unix)
			:
		;;
		
		*)
			bishbosh_exitError "inetFamily '$inetFamily' is not supported"
		;;
	
	esac
	
	# net cat exits when either stdin or stdout 'receives' EOF
	# this is the case if we start netcat with nothing writing to the outbound pipe; this logic keeps a cat running constantly
	# kill -9 $outboundPipeCat will stop the cat, which causes EOF to netcat, which stops netcat
	# unfortunately this design does not allow errors from netcat to be caught
	cat >"$backend_client_outboundPipe" &
	local outboundPipeCat=$!
	backend_client_processIdsToKill+=($outboundPipeCat)
	
	local -i options_instanceId
	options_execute <"$backend_client_outboundPipe" 1>"$backend_client_inboundPipe" 2>"$backend_client_debugLogPath" &

	backend_client_processIdsToKill+=($options_instanceId)
	
	# to get exit code, do wait $netcatInstanceId; then echo $? to get background process exit code. Remember wait could cause set -e to fire!
}

function backend_client_plaintext_netcat-macosx_read()
{
	# If we use sh, then we can use busybox... which internalises the call to od and to nc!
	od --width=1 --address-radix=n --output-duplicates --format=u1 <"$backend_client_inboundPipe"
}

function backend_client_plaintext_netcat-macosx_stop()
{
	_backend_client_stop
}
