function client_backend_plaintext_netcat_load()
{
	declare -a netcatOptions=('nc')
	
	if [ -n "${backend_client_options['inetFamily']}" ]; then
		case "${backend_client_options['inetFamily']}" in
			
			auto)
				:
			;;
			
			inet4)
				netcatOptions+=('-4')
			;;
			
			inet6)
				netcatOptions+=('-6')
			;;

			unix)
				netcatOptions+=('-U')
			;;
			
			*)
				bishbosh_exitError "The backend client 'inetFamily' '${backend_client_options['inetFamily']}' is not known"
			;;
		esac
	fi
	
	if [ -n "${backend_client_options['localInterface']}" ]; then
		netcatOptions+=('-b' "${backend_client_options['localInterface']}")
	fi
	
	if [ -n "${backend_client_options['localAddress']}" ]; then
		netcatOptions+=('-s' "${backend_client_options['localAddress']}")
	fi
	
	if [ -n "${backend_client_options['localPort']}" ]; then
		netcatOptions+=('-p' "${backend_client_options['localPort']}")
	fi
	
	if [ -n "${backend_client_options['timeout']}" ]; then
		local -ir timeout=${backend_client_options['timeout']}
		if [ $timeout -gt 0 ]; then
			netcatOptions+=('-w' $timeout)
		fi
	fi
	
	case "${backend_client_options['proxyKind']}" in
		
		none)
			:
		;;
		
		socks4)
			netcatOptions+=('-X' '4')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		socks5)
			netcatOptions+=('-X' '5')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		https)
			netcatOptions+=('-X' 'connect')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		*)
			bishbosh_exitError "The backend client 'proxyKind' '${backend_client_options['proxyKind']}' is not known"
		;;
		
	esac

	netcatOptions+=("${backend_client_options['remoteAddress']}")
	
	if [ -n "${backend_client_options['remotePort']}" ]; then
		netcatOptions+=("${backend_client_options['remotePort']}")
	fi
	
	# https://unix.stackexchange.com/questions/39362/using-in-out-named-pipes-for-a-tcp-connection
	# http://serverfault.com/questions/188936/writing-to-stdin-of-background-process/297095#297095
	
	# net cat exits when either stdin or stdout 'receives' EOF
	# this is the case if we start netcat with nothing writing to the outbound pipe; this logic keeps a cat running constantly
	# kill -9 $outboundPipeCat will stop the cat, which causes EOF to netcat, which stops netcat
	# unfortunately this design does not allow errors from netcat to be caught
	cat >"$backend_client_outboundPipe" &
	local -ir outboundPipeCat=$!
	backend_client_processIdsToKill+=($outboundPipeCat)
	
	"${netcatOptions[@]}" <"$backend_client_outboundPipe" 1>"$backend_client_inboundPipe" 2>"$backend_client_debugLogPath" &
	local -ir netcatInstanceId=$1
	
	backend_client_processIdsToKill+=($netcatInstanceId)
}

function client_backend_plaintext_netcat_kill()
{
	_backend_client_kill
}
