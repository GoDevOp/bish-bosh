function backend_client_plaintext_netcat_start()
{
	declare -a netcatOptions=('nc')
	
	if [ -n "${backend_client_options['inetFamily']}" ]; then
		case "${backend_client_options['inetFamily']}" in
			
			auto)
				:
			;;
			
			inet4)
				netcatOptions+=('-4')
			;;
			
			inet6)
				netcatOptions+=('-6')
			;;

			unix)
				netcatOptions+=('-U')
			;;
			
			*)
				bishbosh_exitError "The backend client 'inetFamily' '${backend_client_options['inetFamily']}' is not known"
			;;
		esac
	fi
	
	if [ -n "${backend_client_options['localInterface']}" ]; then
		netcatOptions+=('-b' "${backend_client_options['localInterface']}")
	fi
	
	if [ -n "${backend_client_options['localAddress']}" ]; then
		netcatOptions+=('-s' "${backend_client_options['localAddress']}")
	fi
	
	if [ -n "${backend_client_options['localPort']}" ]; then
		netcatOptions+=('-p' "${backend_client_options['localPort']}")
	fi
	
	if [ -n "${backend_client_options['timeout']}" ]; then
		local -ir timeout=${backend_client_options['timeout']}
		if [ $timeout -gt 0 ]; then
			netcatOptions+=('-w' $timeout)
		fi
	fi
	
	case "${backend_client_options['proxyKind']}" in
		
		none)
			:
		;;
		
		socks4)
			netcatOptions+=('-X' '4')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		socks5)
			netcatOptions+=('-X' '5')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		https)
			netcatOptions+=('-X' 'connect')
			netcatOptions+=('-x' "${backend_client_options['proxyAddress']}:${backend_client_options['proxyPort']}")
		;;
		
		*)
			bishbosh_exitError "The backend client 'proxyKind' '${backend_client_options['proxyKind']}' is not known"
		;;
		
	esac

	netcatOptions+=("${backend_client_options['remoteAddress']}:${backend_client_options['remotePort']}")
	
	# net cat exits when either stdin or stdout 'receives' EOF
	# this is the case if we start netcat with nothing writing to the outbound pipe; this logic keeps a cat running constantly
	# kill -9 $outboundPipeCat will stop the cat, which causes EOF to netcat, which stops netcat
	# unfortunately this design does not allow errors from netcat to be caught
	cat >"$backend_client_outboundPipe" &
	local -ir outboundPipeCat=$!
	backend_client_processIdsToKill+=($outboundPipeCat)

	"${netcatOptions[@]}" <"$backend_client_outboundPipe" 1>"$backend_client_inboundPipe" 2>"$backend_client_debugLogPath" &
	local -ir netcatInstanceId=$1

	backend_client_processIdsToKill+=($netcatInstanceId)
}

function backend_client_plaintext_netcat_read()
{
	# If we use sh, then we can use busybox... which internalises the call to od and to nc!
	od --width=1 --address-radix=n --output-duplicates --format=u1 <"$backend_client_inboundPipe"
}

function backend_client_plaintext_netcat_stop()
{
	_backend_client_stop
}
