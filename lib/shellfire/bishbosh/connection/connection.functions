core_usesIn bishbosh/connection read write handler
core_usesIn core children

core_dependency_requires '*' mkdir
bishbosh_connection_mkdirTemporary()
{
	local folderName="$1"
	if [ $# -eq 1 ]; then
		local folderPath="$bishbosh_temporaryFolderPath"/"$bishbosh_connection_id"/"$folderName"
	else
		local folderPath="$2"
	fi
	mkdir -m 0700 -p "$folderPath"
	printf '%s' "$folderPath"
}

core_dependency_requires '*' mkdir
bishbosh_connection_mkdirPermanent()
{
	local folderName="$1"
	if [ $# -eq 1 ]; then
		local folderPath="$bishbosh_connection_clientServersPortsClientIdsPath"/"$folderName"
	else
		local folderPath="$2"
	fi
	mkdir -m 0755 -p "$folderPath"
	printf '%s' "$folderPath"
}

core_dependency_requires '*' mkfifo
bishbosh_connection_mkfifoTemporary()
{
	local fifoName="$1"
	local fifoPath="$bishbosh_connection_fifoFolder"/"$fifoName"
	mkfifo -m 0600 "$fifoPath"
	printf '%s' "$fifoPath"
}

bishbosh_connection_sourceScriptlets()
{
	local path="$1"
	mkdir -m 0755 -p "$path" 2>/dev/null
	
	
	local scriptletFilePath
	if [ ! -d "$scriptletsFolderPath" ]; then
		return 0
	fi
	
	local scriptletPath="$path"/rc
	if core_path_isReadableNonEmptyFilePath "$scriptletPath"; then
		. "$scriptletPath"
	fi
	
	local scriptletsFolderPath="$path"/rc.d
	pushd "$scriptletsFolderPath"
		set +f
			for scriptletFilePath in *.scriptlet
			do
				set -f
				if ! core_path_isReadableNonEmptyFilePath "$scriptletFilePath"; then
					if [ "$scriptletFilePath" = '*.scriptlet' ]; then
						continue
					fi
					core_exitError "The client-id scriptlet file '$scriptletFilePath' is not a readable, non-empty file"
				fi
				
				. ./"$scriptletFilePath"
			done
		set -f
	popd
}
	
bishbosh_connection_defaultEssentialState()
{
	if core_variable_isUnset bishbosh_connection_receivedMessagesPath; then
		bishbosh_connection_receivedMessagesPath="$(bishbosh_connection_mkdirPermanent received-messages)"
	fi
	
	if core_variable_isUnset bishbosh_connection_transmitPath; then
		bishbosh_connection_transmitPath="$(bishbosh_connection_mkdirPermanent transmit)"
	fi
	
	if core_variable_isUnset bishbosh_connection_sessionSession; then
		bishbosh_connection_sessionSession="$(bishbosh_connection_mkdirPermanent session)"
	fi
	
	# Can be overridden, but not listed as possible
	if core_variable_isUnset bishbosh_connection_sessionSubscriptionsPath; then
		bishbosh_connection_sessionSubscriptionsPath="$(bishbosh_connection_mkdirPermanent subscriptions "$bishbosh_connection_sessionSession")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionSubscriptionsSubscribingPath; then
		bishbosh_connection_sessionSubscriptionsSubscribingPath="$(bishbosh_connection_mkdirPermanent subscribing "$bishbosh_connection_sessionSubscriptionsPath")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionSubscriptionsActivePath; then
		bishbosh_connection_sessionSubscriptionsActivePath="$(bishbosh_connection_mkdirPermanent active)"
	fi
	if core_variable_isUnset bishbosh_connection_sessionSubscriptionsUnsubscribingPath; then
		bishbosh_connection_sessionSubscriptionsUnsubscribingPath="$(bishbosh_connection_mkdirPermanent unsubscribing "$bishbosh_connection_sessionSubscriptionsPath")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionPublicationsPath; then
		bishbosh_connection_sessionPublicationsPath="$(bishbosh_connection_mkdirPermanent publications "$bishbosh_connection_sessionSession")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionPublicationsQos2PendingReceivePath; then
		bishbosh_connection_sessionPublicationsQos2PendingReceivePath="$(bishbosh_connection_mkdirPermanent qos2-receive "$bishbosh_connection_sessionPublicationsPath")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionPublicationsQos1PendingSendPath; then
		bishbosh_connection_sessionPublicationsQos1PendingSendPath="$(bishbosh_connection_mkdirPermanent qos1-sent-publish "$bishbosh_connection_sessionPublicationsPath")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionPublicationsQos2PendingSendPath; then
		bishbosh_connection_sessionPublicationsQos2PendingSendPath="$(bishbosh_connection_mkdirPermanent qos2-sent-publish "$bishbosh_connection_sessionPublicationsPath")"
	fi
	if core_variable_isUnset bishbosh_connection_sessionPublicationsQos2PendingCompPath; then
		bishbosh_connection_sessionPublicationsQos2PendingCompPath="$(bishbosh_connection_mkdirPermanent qos2-sent-pubrel "$bishbosh_connection_sessionPublicationsPath")"
	fi
	
	# Allows a logical client-id change to occur
	if core_variable_isUnset bishbosh_connection_write_CONNECT_clientId; then
		bishbosh_connection_write_CONNECT_clientId="$bishbosh_clientId"
	fi
	
	# Should have come from session
	if core_variable_isUnset bishbosh_connection_nextPacketIdentifier; then
		bishbosh_connection_nextPacketIdentifier=0
	fi
	if core_variable_isUnset bishbosh_connection_nextReceivedMessageNumber; then
		bishbosh_connection_nextReceivedMessageNumber=0
	fi
}

bishbosh_connection_obtainConnectionId()
{
	if core_variable_isUnset bishbosh_connection_nextId; then
		bishbosh_connection_id=0
		bishbosh_connection_nextId=0
	else
		bishbosh_connection_id=$bishbosh_connection_nextId
		bishbosh_connection_nextId=$((bishbosh_connection_nextId + 1))
	fi
}

bishbosh_connection_obtainNextSubscriptionIndex()
{
	# Or find . -type f -print | awk -v FS='/' '{print $2}' | sort -n  to get a numerically sorted list. Yuck.
	bishbosh_connection_nextSubscriptionIndex=0
	
	pushd "$bishbosh_connection_sessionSubscriptionsActivePath"
	
		local currentSubscriptionIndex
		local parsedCurrentSubscriptionIndex
		set +f
		for currentSubscriptionIndex in *
		do
			set -f
			if [ ! -e "$currentSubscriptionIndex" ]; then
				# ie '*'
				continue
			fi
			
			# This rather odd logic ensures that a leading-zero padded unsigned decimal integer number is not interpreted as octal
			# Leading-zero padding is used to ensure the shell's glob-expansion sorts in ascending numerical order subscription files
			parsedCurrentSubscriptionIndex=$((1${currentSubscriptionIndex}-1000000000))
			if [ $parsedCurrentSubscriptionIndex -gt $bishbosh_connection_nextSubscriptionIndex ]; then
				bishbosh_connection_nextSubscriptionIndex=$parsedCurrentSubscriptionIndex
			fi
		done
		set -f
	
	popd
}

core_dependency_requires '*' rmdir mkdir
bishbosh_connection_obtainLockForClientId()
{
	# This odd-looking design minimises the time between obtaining the lock (mkdir) and enabling clean-up on exit
	# (there's a slight chance that receiving SIGTERM will leave the lock behind if received between mkdir and assignment of the variable bishbosh_connection_clientIdLockFolderPath)
	bishbosh_connection_clientIdLockFolderPath=''
	_bishbosh_connection_write_removeClientIdLockFolder()
	{
		if [ -n "$bishbosh_connection_clientIdLockFolderPath" ]; then
			rmdir "$bishbosh_connection_clientIdLockFolderPath" 1>/dev/null 2>/dev/null || true
		fi
	}
	core_trap_addOnCleanUp _bishbosh_connection_write_removeClientIdLockFolder
	local lockPath="$bishbosh_connection_clientServersPortsClientIdsPath"/lock
	if mkdir -m 0755 -p "$lockPath"; then
		bishbosh_connection_clientIdLockFolderPath="$lockPath"
	else
		core_exitError "Another process has lock'd Client Id '$bishbosh_connection_write_CONNECT_clientId' at path '$bishbosh_connection_clientIdLockFolderPath'"
	fi
}

core_dependency_requires '*' rm
bishbosh_connection_cleanUpTransmitLockFiles()
{
	pushd "$bishbosh_connection_transmitPath"
		
		local transmitFileLockFolderPath

		set +f
		for transmitFileLockFolderPath in *.lock
		do
			set -f
			rm -rf "$transmitFileLockFolderPath"
		done
		set +f
		
	popd
}

bishbosh_connection_createFifos()
{
	bishbosh_connection_fifoFolder="$(bishbosh_connection_mkdirTemporary fifo)"
	bishbosh_connection_toServerFifo="$(bishbosh_connection_mkfifoTemporary to-server)"
	bishbosh_connection_fromServerFifo="$(bishbosh_connection_mkfifoTemporary from-server)"
	bishbosh_connection_fromHexConversionFifo="$(bishbosh_connection_mkfifoTemporary from-hex-conversion)"
}

bishbosh_connection_startConnectingProgramInBackground()
{
	core_message INFO "Initiating connection '$bishbosh_connection_id' to server '$bishbosh_server' with temporary path '$bishbosh_temporaryFolderPath/$bishbosh_connection_id'"
	bishbosh_client_plaintext_${bishbosh_client_plaintext}_start
	bishbosh_connection_clientPid=$!
	core_children_killOnExit $bishbosh_connection_clientPid
}

core_dependency_requires '*' mkdir
core_dependency_oneOf '*' hexdump od
bishbosh_connection_makeClientConnection()
{
	if core_variable_isUnset bishbosh_connection_clientServersPath; then
		bishbosh_connection_clientServersPath="$bishbosh_clientPath"/servers/"$bishbosh_server"
		bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPath"
	fi
	
	if core_variable_isUnset bishbosh_connection_clientServersPortsPath; then
		bishbosh_connection_clientServersPortsPath="$bishbosh_connection_clientServersPath"/ports/"$bishbosh_port"
		bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsPath"
	fi
	
	if core_variable_isUnset bishbosh_connection_clientServersPortsClientIdsPath; then
		bishbosh_connection_clientServersPortsClientIdsPath="$bishbosh_connection_clientServersPortsPath"/client-ids/"$bishbosh_clientId"
		bishbosh_connection_sourceScriptlets "$bishbosh_connection_clientServersPortsClientIdsPath"
	fi
	
	mkdir -m 0755 -p "$bishbosh_connection_clientServersPortsClientIdsPath" 2>/dev/null || core_exitError "Could not create bishbosh_connection_clientServersPortsClientIdsPath '$bishbosh_connection_clientServersPortsClientIdsPath'"
	bishbosh_connection_obtainLockForClientId
	
	bishbosh_connection_sourcePerServerScriptlets
	bishbosh_connection_sourcePerServerPerPortScriptlets
	bishbosh_connection_sourcePerServerPerClientIdScriptlets
	
	bishbosh_connection_defaultEssentialState
	
	bishbosh_connection_obtainConnectionId
	bishbosh_connection_obtainNextSubscriptionIndex
	bishbosh_connection_cleanUpTransmitLockFiles
	bishbosh_connection_createFifos
	
	bishbosh_connection_read_initialise 'no'
	bishbosh_connection_continue=true
	set -x
	bishbosh_connection_startConnectingProgramInBackground
	set +x
	exit 50
	
	# http://mywiki.wooledge.org/SignalTrap
	# http://www.cons.org/cracauer/sigint.html
	# Assumes we are in a blocking read
	trap '' INT TERM
	if [ "$core_init_preferredShell" = 'bash' ]; then
		trap 'bishbosh_connection_continue=false; return 0' INT TERM
	else
		# tested on dash
		trap 'bishbosh_connection_continue=false' INT TERM
	fi
	
	
	$bishbosh_connection_read_loop
}

bishbosh_connection_nextPacketIdentifier()
{
	printf '%s' $bishbosh_connection_nextPacketIdentifier
	if [ $bishbosh_connection_nextPacketIdentifier -eq 65535 ]; then
		bishbosh_connection_nextPacketIdentifier=0
	else
		bishbosh_connection_nextPacketIdentifier=$((bishbosh_connection_nextPacketIdentifier+1))
	fi
}

bishbosh_connection_readPacketIdentifier()
{
	local packetIdentifierMsb
	local packetIdentifierLsb
	$bishbosh_connection_read_byte_blocking packetIdentifierMsb
	$bishbosh_connection_read_byte_blocking packetIdentifierLsb
	
	packetIdentifier=$((packetIdentifierMsb * 256 + packetIdentifierLsb))
	
	# We should now 'free' the packet identifier...
}

bishbosh_connection_readLength()
{
	local lengthMsb
	local lengthLsb
	$bishbosh_connection_read_byte_blocking lengthMsb
	$bishbosh_connection_read_byte_blocking lengthLsb
	
	length=$((lengthMsb * 256 + lengthLsb))
}

core_dependency_requires '*' rmdir mkdir sleep rm
bishbosh_connection_writeLoop()
{
	bishbosh_connection_writeLoopControlLockFolderPath=''
	_bishbosh_connection_writeLoopRemoveControlLockFolder()
	{
		if [ -n "$bishbosh_connection_writeLoopControlLockFolderPath" ]; then
			rmdir "$bishbosh_connection_writeLoopControlLockFolderPath" 1>/dev/null 2>/dev/null || true
		fi
	}
	core_trap_addOnCleanUp _bishbosh_connection_writeLoopRemoveControlLockFolder

	local transmitFilePath
	pushd "$bishbosh_connection_transmitPath"
		
		{
			while $bishbosh_connection_continue
			do
				bishbosh_connection_handler_beforeWrite
				
				set +f
				for transmitFilePath in *.transmit
				do
					set -f
					if ! core_path_isReadableNonEmptyFilePath "$transmitFilePath"; then
						if [ "$transmitFilePath" = '*.control' ]; then
							continue
						fi
						core_exitError "The transmit file '$transmitFilePath' is not a readable, non-empty file"
					fi
		
					bishbosh_connection_writeLoopControlLockFolderPath="$transmitFilePath".lock
					# Atomic, according to http://wiki.bash-hackers.org/howto/mutex
					while ! mkdir "$bishbosh_connection_writeLoopControlLockFolderPath" 2>/dev/null
					do
						sleep $bishbosh_lockLatency_inFractionalSeconds
					done
		
					. ./"$transmitFilePath"
					
					rm -f "$transmitFilePath"
					rmdir "$bishbosh_connection_writeLoopControlLockFolderPath"
					bishbosh_connection_writeLoopControlLockFolderPath=''
				done
				set -f
			
				bishbosh_connection_handler_afterWrite
			done
			
			bishbosh_connection_write_DISCONNECT
			
		} >"$bishbosh_connection_toServerFifo"
		
	popd
}