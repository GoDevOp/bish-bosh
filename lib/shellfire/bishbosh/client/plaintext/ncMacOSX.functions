core_usesIn core functions
core_functions_register _bishbosh_client_plaintext_registration ncMacOSX

#bishbosh_client_features_ncMacOSX_sourceInterface=yes   BSD nc only
bishbosh_client_features_ncMacOSX_sourcePort=yes
bishbosh_client_features_ncMacOSX_sourceAddress=yes
bishbosh_client_features_ncMacOSX_ipV4Only=yes
bishbosh_client_features_ncMacOSX_ipV6Only=yes
bishbosh_client_features_ncMacOSX_unixDomainSocketOnly=yes
bishbosh_client_features_ncMacOSX_proxySocks4=yes
bishbosh_client_features_ncMacOSX_proxySocks4UserPassword=no
bishbosh_client_features_ncMacOSX_proxySocks5=yes
bishbosh_client_features_ncMacOSX_proxySocks5UserPassword=no
bishbosh_client_features_ncMacOSX_proxyHttp=yes
bishbosh_client_features_ncMacOSX_proxyHttpUsernamePassword=no
#bishbosh_client_features_ncMacOSX_timeout=yes  - nc, this is send/receive; tcpclient, this is connection timeout
# tcpclient
bishbosh_client_features_ncMacOSX_tcpNoDelayToggling=no

_backend_client_plaintext_ncMacOSX_start_addProxy()
{
	local proxyValue="$1"
	bishbosh_client_addOptionWithEmptyMeaningNo '-X' "$proxyValue"
	
	local proxyAddress="$bishbosh_proxyAddress"
	if core_variable_isSet bishbosh_proxyPort; then
		# Note, if using an IPv6 address, we'll need surrounding []
		proxyAddress="${proxyAddress}:${bishbosh_proxyPort}"
	fi
	
	bishbosh_client_addOptionWithEmptyMeaningNo '-x' "$proxyAddress"
	
	if core_variable_isSet bishbosh_proxyUsername; then
		core_message WARN "The backend ncMacOSX does not support specifing the proxy username"
	fi
	if core_variable_isSet bishbosh_proxyPassword; then
		core_message WARN "The backend ncMacOSX does not support specifing the proxy password"
	fi
}

# Also -K tclass and -F options are in the commandline help (but not the man page)!
core_usesIn core variable variable/array
backend_client_plaintext_ncMacOSX_start()
{
	local options
	core_variable_array_initialise options
	
	local isUnixDomainSocket
	if core_variable_isSet bishbosh_transport; then
		case "$bishbosh_transport" in
			
			inet4)
				core_variable_array_appendAsOptionArg '-4'
			;;
			
			inet6)
				core_variable_array_appendAsOptionArg '-6'
			;;
			
			unix)
				core_variable_array_appendAsOptionArg '-U'
			;;
			
			inet)
				:
			;;
			
			*)
				core_exitError $core_commandLine_exitCode_SOFTWARE "Please validate the values for bishbosh_transport"
			;;
			
		esac
	fi
	
	bishbosh_client_addOptionWithEmptyMeaningNo '-s' "$bishbosh_sourceAddress"
	bishbosh_client_addOptionWithEmptyMeaningNo '-p' "$bishbosh_sourcePort"
	
	case "$bishbosh_proxyKind" in
		
		'SOCKS4')
			_backend_client_plaintext_ncMacOSX_start_addProxy '4'
		;;
		
		'SOCKS5')
			_backend_client_plaintext_ncMacOSX_start_addProxy '5'
		;;
		
		'HTTP')
			_backend_client_plaintext_ncMacOSX_start_addProxy 'connect'
		;;
		
	esac

	# Occurs because of a bad connection (connection refused)
	# /Users/raph/Documents/bish-bosh/source/functions/write/controlpacket.functions: line 209: printf: write error: Bad file descriptor
	# nc has exited - how do we detect this? just try to write and TRAP the error? Use SIGCHLD?
	# also need to trap clean up
	
	# https://stackoverflow.com/questions/6702474/bash-best-architecture-for-reading-from-two-input-streams
	
	local connectionId=100
	
	# Useless logic without named pipes
	# There is an order to named pipes
	mkfifo output
	mkfifo 
	
	# We can not detect errors from the connection this way; this is quite a limitation
	core_variable_array_passToFunctionAsArguments options nc | od --width=1 --address-radix=n --output-duplicates --format=u1 | while true
	do
		bishbosh_write_controlpacket_CONNECT_arguments_clean_session=yes
		#bishbosh_write_controlpacket_CONNECT_arguments_willTopic=
		#bishbosh_write_controlpacket_CONNECT_arguments_willMessage=
		#bishbosh_write_controlpacket_CONNECT_arguments_willQos=0
		#bishbosh_write_controlpacket_CONNECT_arguments_willRetain=no
		bishbosh_write_controlpacket_CONNECT_arguments_keepAlive=0
		bishbosh_write_controlpacket_CONNECT_arguments_clientId=MY-CLIENT-ID
		bishbosh_write_controlpacket_CONNECT_arguments_username=user
		bishbosh_write_controlpacket_CONNECT_arguments_password=password
		bishbosh_write_controlpacket_CONNECT

		# We should have a connection object we update
		read_controlpacket_next

		write_controlpacket_PINGREQ

		read_controlpacket_next

		write_controlpacket_DISCONNECT
	done
}
