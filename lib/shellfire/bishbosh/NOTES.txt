	# https://stackoverflow.com/questions/9536388/capture-pid-of-terminated-background-process-using-trap-in-bash?rq=1
	# http://mywiki.wooledge.org/ProcessManagement#I_want_to_process_a_bunch_of_files_in_parallel.2C_and_when_one_finishes.2C_I_want_to_start_the_next._And_I_want_to_make_sure_there_are_exactly_5_jobs_running_at_a_time
	
	
	core_TODO 'password, will payload can contain embedded ASCII NULL!'
	core_TODO 'consider loading username, password, will details based on client-id...'
	core_TODO 'keep-alive is based on server connection details - it is a broker specific thing - goes with broker configurations'
	core_TODO 'Support a binary password (embedded NULs)'
	core_TODO 'Use .netrc for password! (or a password file; required if we are going to use embedded NULs for SASL)'
	
# using netcat with a FIFO (need mkfifo): https://unix.stackexchange.com/questions/39362/using-in-out-named-pipes-for-a-tcp-connection
# reverse bash shell http://www.gnucitizen.org/blog/reverse-shell-with-bash/
# reverse nc if nc is broken (lacks -e) http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
# reverse shell using GAWK! http://www.gnucitizen.org/blog/reverse-shell-with-bash/#comment-122387
function backend_client_plaintext_bash_start()
{
	if [ -n "${backend_client_options['inetFamily']}" ]; then
		case "${backend_client_options['inetFamily']}" in
			
			auto)
				:
			;;
			
			inet4)
				:
			;;
			
			inet6)
				bishbosh_message WARN "The backend 'client plaintext bash' does not support setting the localInterface"
			;;

			unix)
				bishbosh_exitError "The backend client 'inetFamily' '${backend_client_options['inetFamily']}' is not supported for the backend 'client plaintext bash'"
			;;
			
			*)
				bishbosh_exitError "The backend client 'inetFamily' '${backend_client_options['inetFamily']}' is not known"
			;;
		esac
	fi
	
	if [ -n "${backend_client_options['localInterface']}" ]; then
		bishbosh_message WARN "The backend 'client plaintext bash' does not support setting the localInterface"
	fi
	
	if [ -n "${backend_client_options['localAddress']}" ]; then
		bishbosh_message WARN "The backend 'client plaintext bash' does not support setting the localAddress"
	fi
	
	if [ -n "${backend_client_options['localPort']}" ]; then
		bishbosh_message WARN "The backend 'client plaintext bash' does not support setting the localPort"
	fi
	
	if [ -n "${backend_client_options['timeout']}" ]; then
		bishbosh_message WARN "The backend 'client plaintext bash' does not support setting a timeout"
	fi
	
	case "${backend_client_options['proxyKind']}" in
		
		none)
			:
		;;
		
		socks4|socks5|https)
			bishbosh_exitError "The backend 'client plaintext bash' does not support a proxy"
		;;
		
		*)
			bishbosh_exitError "The backend client 'proxyKind' '${backend_client_options['proxyKind']}' is not known"
		;;
		
	esac
	
	exec 3<>/dev/tcp/"${backend_client_options['remoteAddress']}"/"${backend_client_options['remotePort']}"
}

function backend_client_plaintext_bash_read()
{
	od --width=1 --address-radix=n --output-duplicates --format=u1 <&3
}

function backend_client_plaintext_bash_stop()
{
	exec 3<&-
	exec 3>&-
}
function backend_client_defaultOptions()
{
	backend_client_options_tunnelling=plaintext
	
	# Choices are auto (best fit), inet4, inet6, unix
	backend_client_options_inetFamily=auto
	#backend_client_options_localInterface
	#backend_client_options_localAddress
	#backend_client_options_localPort
	
	#backend_client_options_proxyKind
	#backend_client_options_proxyAddress
	#backend_client_options_proxyPort=

	#backend_client_options_timeout
	
	#backend_client_options_remoteAddress
	#backend_client_options_remotePort
}

backend_client_temporaryPath=""
function backend_client_createTemporaryPath()
{
	temporaryFiles_newFolderToRemoveOnExit
	backend_client_temporaryPath="$TMP_FOLDER"
}

backend_client_debugLogPath=""
function backend_client_createDebugLog()
{
	backend_client_debugLogPath="$backend_client_temporaryPath"/client.debug.log
	touch "$backend_client_debugLogPath"
}

backend_client_inboundPipe=''
backend_client_outboundPipe=''
function backend_client_createNamedPipes()
{
	backend_client_inboundPipe="$backend_client_temporaryPath"/client.inbound.pipe
	backend_client_outboundPipe="$backend_client_temporaryPath"/client.outbound.pipe
	mkfifo "$backend_client_inboundPipe" "$backend_client_outboundPipe"
}

function backend_client_get_tunelling()
{
	if [ "${backend_client_options_tunnelling+unset}" = 'unset' ]; then
		tunelling=plaintext
	elif [ -z "$backend_client_options_tunnelling" ]; then
		bishbosh_exitError 'backend_client_options_tunnelling '$backend_client_options_tunnelling' (empty) is invalid'
	else
		
		case "$backend_client_options_tunnelling" in
			
			plaintext|ssh|tls)
				tunelling="$backend_client_options_tunnelling"
			;;
			
			*)
				bishbosh_exitError "backend_client_options_tunelling '$backend_client_options_tunelling' is not known"
			;;
			
		esac
		
	fi
}

function backend_client_get_timeout()
{
	if [ ${backend_client_options_timeout+unset} = 'unset' ]; then
		timeout=0
		return
	fi
	if [ -z "$backend_client_options_timout" ]; then
		bishbosh_exitError 'backend_client_options_timout '$backend_client_options_timeout' (empty) is invalid'
	fi
	timeout=$backend_client_options_timout
	if [ "$timeout" != "$backend_client_options_timout" ]; then
		bishbosh_exitError 'backend_client_options_timout '$backend_client_options_timeout' must be a positive decimal integer (in seconds) or 0 (infinity)'
	fi
	if [ $timeout -lt 0 ]; then
		bishbosh_exitError 'backend_client_options_timout '$backend_client_options_timeout' must be a positive decimal integer (in seconds) or 0 (infinity)'
	fi
}

function backend_client_get_inetFamily()
{
	if [ "${backend_client_options_inetFamily+unset}" = 'unset' ]; then
		inetFamily=auto
	elif [ -z "$backend_client_options_inetFamily" ]; then
		bishbosh_exitError "backend_client_options_inetFamily '$backend_client_options_inetFamily' (empty) is required"
	else
		case "$backend_client_options_inetFamily" in
			
			auto|inet4|inet6|unix)
				inetFamily="$backend_client_options_inetFamily"
			;;
			
			*)
				bishbosh_exitError "backend_client_options_inetFamily '$backend_client_options_inetFamily' is not known"
			;;
			
		esac
	fi
}

function backend_client_get_proxyKind()
{
	if [ "${inetFamily+unset}" = 'unset' ]; then
		bishbosh_exitError "Please call backend_client_get_inetFamily first"
	fi
	if [ "$inetFamily" = 'unix' ]; then
		bishbosh_exitError "backend_client_options_proxyKind '$(backend_client_get_proxyKind)' is not supported when backend_client_options_inetFamily is 'unix' (Unix Domain Sockets do not support proxies)"
	fi
	if [ "${backend_client_options_proxyKind+unset}" = 'unset' ]; then
		proxyKind='none'
	elif [ -z "$backend_client_options_proxyKind" ]; then
		bishbosh_exitError "backend_client_options_proxyKind '$backend_client_options_proxyKind' (empty) is required"
	else
		case "$backend_client_options_proxyKind" in
			
			none|socks4|socks5|https)
				proxyKind="$backend_client_options_proxyKind"
			;;
			
			*)
				bishbosh_exitError "backend_client_options_proxyKind '$backend_client_options_proxyKind' is not valid"
			;;
		esac
	fi
}

function backend_client_get_proxyAddress()
{
	if [ "${proxyKind+unset}" = 'unset' ]; then
		bishbosh_exitError "Please call backend_client_get_proxyKind first"
	fi
	
	if [ "$proxyKind" = 'none' ]; then
		bishbosh_exitError "Do not call backend_client_get_proxyAddress if proxyKind is 'none'"
	fi
	
	if [ "${backend_client_options_proxyAddress+unset}" = 'unset' ]; then
		bishbosh_exitError "proxyKind '$proxyKind' does not have a known default proxyAddress; please set backend_client_options_proxyAddress"
	elif [ -z "$backend_client_options_proxyAddress" ]; then
		bishbosh_exitError "backend_client_options_proxyAddress '$backend_client_options_proxyAddress' (empty) is required"
	else
		proxyAddress="$backend_client_options_proxyAddress"
	fi
}

function backend_client_get_proxyPort()
{
	if [ "${proxyKind+unset}" = 'unset' ]; then
		bishbosh_exitError "Please call backend_client_get_proxyKind first"
	fi
	
	if [ "$proxyKind" = 'none' ]; then
		bishbosh_exitError "Do not call backend_client_get_proxyPort if proxyKind is 'none'"
	fi
	
	if [ "${backend_client_options_proxyPort+unset}" = 'unset' ]; then
		
		case "$proxyKind" in
			
			socks4|socks5
				proxyPort=1080
			;;
			
			https)
				proxyPort=3128
			;;
			
			*)
				bishbosh_exitError "proxyKind '$proxyKind' does not have a known default proxyPort; please set backend_client_options_proxyPort"
			;;
			
		esac
		
	elif [ -z "$backend_client_options_proxyPort" ]; then
		bishbosh_exitError "backend_client_options_proxyKind '$backend_client_options_proxyKind' (empty) is required"
	else
		proxyPort=$backend_client_options_proxyPort
		if [ "$proxyPort" != "$backend_client_options_proxyPort" ]; then
			bishbosh_exitError "backend_client_options_proxyPort '$backend_client_options_proxyPort' must be a decimal integer"
		fi
		if [ $proxyPort -lt 1 ]; then
			bishbosh_exitError "backend_client_options_proxyPort '$backend_client_options_proxyPort' must be between 1 and 65535"
		fi
		if [ $proxyPort -gt 65535 ]; then
			bishbosh_exitError "backend_client_options_proxyPort '$backend_client_options_proxyPort' must be between 1 and 65535"
		fi
	fi
}

function backend_client_get_remoteAddress()
{
	if [ "${inetFamily+unset}" = 'unset' ]; then
		bishbosh_exitError "Please call backend_client_get_inetFamily first"
	fi
	if [ "${backend_client_options_remoteAddress+unset}" ]; then
		
		case "$inetFamily" in
			
			auto|inet4|inet6)
				remoteAddress=localhost
			;;
			
			*)
				bishbosh_exitError "inetFamily '$inetFamily' does not have a known default remoteAddress; please set backend_client_options_remoteAddress"
			;;
			
		esac
	else
		remoteAddress="$backend_client_options_remoteAddress"
	fi

	if [ "$proxyAddress" = "$remoteAddress" ]; then
		bishbosh_exitError "proxyAddress '$proxyAddress' is the same as remoteAddress '$remoteAddress'"
	fi
}

function backend_client_get_remotePort()
{
	if [ "${inetFamily+unset}" = 'unset' ]; then
		bishbosh_exitError "Please call backend_client_get_inetFamily first"
	fi
	if [ "${backend_client_options_remotePort+unset}" ]; then
		
		case "$inetFamily" in
			
			auto|inet4|inet6)
				
				if [ "${backend_client_options_tunnelling+unset}" = 'unset' ]; then
					bishbosh_exitError "inetFamily '$inetFamily' does not have a known default remotePort because backend_client_options_tunnelling in unset; please set backend_client_options_tunnelling"
				fi
				
				if [ -z "${backend_client_options_tunnelling+unset}" = 'unset' ]; then
					bishbosh_exitError "inetFamily '$inetFamily' does not have a known default remotePort because backend_client_options_tunnelling in empty; please specify backend_client_options_tunnelling"
				fi
				
				case "$backend_client_options_tunnelling"
					
					plaintext|ssh)
						remotePort=1883
					;;
					
					tls)
						remotePort=8883
					;;
					
					*)
						bishbosh_exitError "backend_client_options_tunnelling '$backend_client_options_tunnelling' does not have a known default remotePort; please set backend_client_options_tunnelling"
					;;
					
				esac
			;;
			
			*)
				bishbosh_exitError "inetFamily '$inetFamily' does support a remotePort"
			;;
			
		esac
	elif [ -z "$backend_client_options_remotePort" ]; then
		bishbosh_exitError "backend_client_options_remotePort '$backend_client_options_remotePort' (empty) is required"
	else	
		remotePort=$backend_client_options_remotePort
		if [ "$remotePort" != "$backend_client_options_remotePort" ]; then
			bishbosh_exitError "backend_client_options_remotePort '$backend_client_options_remotePort' must be a decimal integer"
		fi
		if [ $remotePort -lt 1 ]; then
			bishbosh_exitError "backend_client_options_remotePort '$backend_client_options_remotePort' must be between 1 and 65535"
		fi
		if [ $remotePort -gt 65535 ]; then
			bishbosh_exitError "backend_client_options_remotePort '$backend_client_options_remotePort' must be between 1 and 65535"
		fi
	fi
	
	if [ "$proxyPort" = "$remotePort" ]; then
		bishbosh_exitError "proxyPort '$proxyPort' is the same as remotePort '$remotePort'"
	fi
}

function backend_client_normaliseOptions()
{
	if [ "$backend_client_options_proxyKind" = 'none' ]; then
		if [ -n "$backend_client_options_proxyAddress" ]; then
			bishbosh_exitError "Backend client 'proxyAddress' is set but proxyKind is missing or none"
		fi
		if [ -n "$backend_client_options_proxyPort" ]; then
			bishbosh_exitError "Backend client 'proxyPort' is set but proxyKind is missing or none"
		fi
	else
		if [ -z "$backend_client_options_proxyAddress]" ]; then
			bishbosh_exitError "Backend client 'proxyAddress' is not set but proxyKind is $backend_client_options_proxyKind"
		fi
		if [ -z "$backend_client_options_proxyPort" ]; then
			case "$backend_client_options_proxyKind" in
				
				socks4|socks5)
					backend_client_options_proxyPort=1080
				;;
				
				https)
					backend_client_options_proxyPort=3128
				;;
				
			esac
			
		fi
	fi
	
	# depends on security setting
	if [ -z "$backend_client_options_remotePort" ]; then
		if [ "$backend_client_options_proxyKind" != 'unix' ]; then
			backend_client_options_remotePort=1883
		fi
	fi
	
	if [ "$backend_client_options_proxyKind" = 'unix' ]; then
		if [ -n "$backend_client_options_remotePort" ]; then
			bishbosh_exitError "Backend client 'inetFamily' is unix but a remotePort of '$backend_client_options_remotePort' has been set"
		fi
	fi
	
	local remoteAddress="$backend_client_options_remoteAddress"
	if [ -z "$remoteAddress" ]; then
		bishbosh_exitError "Backend client 'remoteAddress' is not set"
	else
		if [ "$remoteAddress" = "$backend_client_options[proxyAddress]" ]; then
			if [ "$backend_client_options_proxyPort" = "$backend_client_options_proxyPort" ]; then
				bishbosh_exitError "Backend client 'proxyAddress' and 'proxyPort' are the same as 'remoteAddress' and 'remotePort'"
			fi
		fi
	fi
}

backend_kind=""
backend_name=""
backend_client_prefix=""
backend_client_processIdsToKill=()
function backend_client_start()
{	
	backend_kind="$1"
	backend_name="$2"
	backend_client_processIdsToKill=()
	
	backend_client_normaliseOptions

	backend_client_createTemporaryPath
	
	backend_client_createDebugLog
	
	backend_client_createNamedPipes
	
	backend_client_prefix="backend_client_${backend_kind}_${backend_name}"
	uses backend.client.${backend_kind}.${backend_name}
	${backend_client_prefix}_start
}

function backend_client_loop()
{
		exec 10<"$backend_client_outboundPipe"
		exec 11</dev/null
	
		# HERE: Add trap handler to clean up a connection
	
		# Occurs because of a bad connection (connection refused)
		# /Users/raph/Documents/bish-bosh/source/functions/write/controlpacket.functions: line 209: printf: write error: Bad file descriptor
		# nc has exited - how do we detect this? just try to write and TRAP the error?
		# also need to trap clean up
	
		local connectionId=100
	
		connection_write_CONNECT_arguments_clean_session=yes
		#connection_write_CONNECT_arguments_will_topic=
		#connection_write_CONNECT_arguments_will_message=
		#connection_write_CONNECT_arguments_will_qos=0
		#connection_write_CONNECT_arguments_will_retain=no
		connection_write_CONNECT_arguments_keep_alive=0
		connection_write_CONNECT_arguments_client_id=MY-CLIENT-ID
		connection_write_CONNECT_arguments_username=user
		connection_write_CONNECT_arguments_password=password
	
		connection_write_CONNECT
	
		while true
		do
			# We should have a connection object we update
			connection_read_next
	
			connection_write_PINGREQ
	
			connection_read_next
	
			connection_write_DISCONNECT
		
			done < <(${backend_client_prefix}_read)

		exec 10<&-
		exec 11<&-
	
		
	return 0
	
	
	# we could publish messages that are 'dropped' into a folder. The folder name could be the topic, the QoS a folder prefix, leaving just a way to notify
	# could be a find with a sort, followed by a pause (for a read cycle). Or the read cycle could be size-based, eg after writing 4Kb or 1 second?
	
	# we call a callback (or callbacks) on message recipt. This can be either a built-in or a function or an external program. Slight problem in sending array variables to a program
	# consider not using arrays for connection_write_*
	
	# message records call callbacks. These can be either built in functions or real programs; we pass a QoS, Topic and Path to content (or named pipe) (or an array of functions/programs)
	
	# check that the underlying process(es) have not died, otherwise we could block writing to the FIFO...
	# we should not write more than 4Kb to the FIFO...
	
}

function backend_client_stop()
{
	${backend_client_prefix}_stop
	
	backend_client_deleteNamedPipes
}

function backend_client_deleteNamedPipes()
{
	rm -rf "$backend_client_inboundPipe"
	rm -rf "$backend_client_outboundPipe"
}

function _backend_client_stop()
{
	local -i pid
	for pid in ${backend_client_processIdsToKill[@]}
	do
		kill -9 $pid 1>/dev/null 2>/dev/null || true
	done
	backend_client_processIdsToKill=()
}
function configuration_client_netrc()
{
	local serverName="$1"
	local netrcFilePath="$2"

	if [ ! -f "$netrcFilePath" ]; then
		return 0
	fi
	if [ ! -r "$netrcFilePath" ]; then
		return 0
	fi
	if [ ! -s "$netrcFilePath" ]; then
		return 0
	fi
	
	# tokens may be separated by spaces, tabs or NEWLINES...
	# macdef causes problems - starts on next line and continues until \n\n encountered
	local machine machineName login loginName password passwordName 
	while read -r 
	
	# finds username, password
	
	# could we parse curlrc files?
	
	# could we use http_proxy / https_proxy env variables?
	
	# could we do look-up in DNS for SRV records?
	
	# we could use .wgetrc files, too /etc/wgetrc
	
	# Some versions of nc support -P for proxy password (? Mac OS X does not ?)
	
	# wget seems to be the originator of these; upper cases variants for windows seem common....
	# we can also use libproxy
	# For generic SOCKS handling, consider tsocks and proxychains-ng
	#typical values are https://USER@PASSWORD:ADDRESS:PORT/
    #export http_proxy=http://10.203.0.1:5187/
    #export https_proxy=$http_proxy
    #export ftp_proxy=$http_proxy
    #export rsync_proxy=$http_proxy
    #export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com"
}
